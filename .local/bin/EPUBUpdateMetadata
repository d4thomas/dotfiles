#!/usr/bin/env -S uv run --quiet --script
# /// script
# dependencies = [
#   "lxml>=4.9.0",
# ]
# ///

import sys
import os
import zipfile
import tempfile
import argparse
from pathlib import Path
from lxml import etree

# Namespace map
NSMAP = {
    'opf': 'http://www.idpf.org/2007/opf',
    'dc': 'http://purl.org/dc/elements/1.1/',
}


def find_opf_file(epub_path):
    """Find the OPF file path within the EPUB"""
    with zipfile.ZipFile(epub_path, 'r') as zip_ref:
        try:
            container_data = zip_ref.read('META-INF/container.xml')
            container_tree = etree.fromstring(container_data)
            rootfile = container_tree.find('.//{urn:oasis:names:tc:opendocument:xmlns:container}rootfile')
            if rootfile is not None:
                return rootfile.get('full-path')
        except:
            pass

        for name in zip_ref.namelist():
            if name.endswith('.opf'):
                return name
    return None


def show_metadata(epub_file):
    """Display EPUB metadata without modifying"""
    opf_path = find_opf_file(epub_file)
    if not opf_path:
        print(f"  Error: Could not find OPF file")
        return False

    with tempfile.TemporaryDirectory() as temp_dir:
        # Extract EPUB
        with zipfile.ZipFile(epub_file, 'r') as zip_ref:
            zip_ref.extractall(temp_dir)

        # Parse OPF with lxml
        opf_full_path = os.path.join(temp_dir, opf_path)
        parser = etree.XMLParser(remove_blank_text=False, resolve_entities=False)
        tree = etree.parse(opf_full_path, parser)
        root = tree.getroot()

        # Get title
        title_elem = root.find('.//dc:title', namespaces=NSMAP)
        title = title_elem.text if title_elem is not None else "(none)"

        # Get sort title
        sort_title = None
        if title_elem is not None:
            title_id = title_elem.get('id')
            if title_id:
                for meta in root.findall('.//opf:meta', namespaces=NSMAP):
                    if meta.get('refines') == f'#{title_id}' and meta.get('property') == 'file-as':
                        sort_title = meta.text
                        break

        # Get author
        author_elem = root.find('.//dc:creator', namespaces=NSMAP)
        author = author_elem.text if author_elem is not None else "(none)"

        # Get sort author
        sort_author = None
        if author_elem is not None:
            author_id = author_elem.get('id')
            if author_id:
                for meta in root.findall('.//opf:meta', namespaces=NSMAP):
                    if meta.get('refines') == f'#{author_id}' and meta.get('property') == 'file-as':
                        sort_author = meta.text
                        break

        # Get publisher
        publisher_elem = root.find('.//dc:publisher', namespaces=NSMAP)
        publisher = publisher_elem.text if publisher_elem is not None else "(none)"

        # Display metadata
        print(f"  Title:        {title}")
        if sort_title:
            print(f"  Sort Title:   {sort_title}")
        print(f"  Author:       {author}")
        if sort_author:
            print(f"  Sort Author:  {sort_author}")
        print(f"  Publisher:    {publisher}")

    return True


def update_metadata(epub_file, new_title=None, new_author=None, new_publisher=None):
    """Update EPUB metadata in-place"""
    opf_path = find_opf_file(epub_file)
    if not opf_path:
        print(f"  Error: Could not find OPF file")
        return False

    with tempfile.TemporaryDirectory() as temp_dir:
        # Extract EPUB
        with zipfile.ZipFile(epub_file, 'r') as zip_ref:
            zip_ref.extractall(temp_dir)

        # Parse OPF with lxml
        opf_full_path = os.path.join(temp_dir, opf_path)
        parser = etree.XMLParser(remove_blank_text=False, resolve_entities=False)
        tree = etree.parse(opf_full_path, parser)
        root = tree.getroot()

        updated = False

        # Update title
        if new_title:
            title_elem = root.find('.//dc:title', namespaces=NSMAP)
            if title_elem is not None:
                old_title = title_elem.text
                title_elem.text = new_title
                print(f"  Title: '{old_title}' -> '{new_title}'")

                # Update title-sort (file-as) if it exists
                title_id = title_elem.get('id')
                if title_id:
                    # Look for <meta refines="#id" property="file-as">
                    for meta in root.findall('.//opf:meta', namespaces=NSMAP):
                        if meta.get('refines') == f'#{title_id}' and meta.get('property') == 'file-as':
                            meta.text = new_title
                            print(f"  Updated sort title to '{new_title}'")
                            break
                updated = True
            else:
                print(f"  Warning: No title element found")

        # Update author
        if new_author:
            author_elem = root.find('.//dc:creator', namespaces=NSMAP)
            if author_elem is not None:
                old_author = author_elem.text
                author_elem.text = new_author
                print(f"  Author: '{old_author}' -> '{new_author}'")

                # Update author-sort (file-as) if it exists
                author_id = author_elem.get('id')
                if author_id:
                    for meta in root.findall('.//opf:meta', namespaces=NSMAP):
                        if meta.get('refines') == f'#{author_id}' and meta.get('property') == 'file-as':
                            meta.text = new_author
                            print(f"  Updated sort author to '{new_author}'")
                            break
                updated = True
            else:
                print(f"  Warning: No author element found")

        # Update publisher
        if new_publisher:
            publisher_elem = root.find('.//dc:publisher', namespaces=NSMAP)
            if publisher_elem is not None:
                old_publisher = publisher_elem.text
                publisher_elem.text = new_publisher
                print(f"  Publisher: '{old_publisher}' -> '{new_publisher}'")
                updated = True
            else:
                # Create publisher element if it doesn't exist
                metadata_elem = root.find('.//opf:metadata', namespaces=NSMAP)
                if metadata_elem is not None:
                    publisher_elem = etree.SubElement(
                        metadata_elem,
                        f'{{{NSMAP["dc"]}}}publisher'
                    )
                    publisher_elem.text = new_publisher
                    print(f"  Publisher: (none) -> '{new_publisher}'")
                    updated = True
                else:
                    print(f"  Warning: No metadata element found")

        if not updated:
            print(f"  No metadata updated")
            return False

        # Write back with exact formatting preserved
        tree.write(opf_full_path, encoding='utf-8', xml_declaration=True, pretty_print=False)

        # Repack EPUB
        with zipfile.ZipFile(epub_file, 'w', zipfile.ZIP_DEFLATED) as zip_out:
            mimetype_path = os.path.join(temp_dir, 'mimetype')
            if os.path.exists(mimetype_path):
                zip_out.write(mimetype_path, 'mimetype', compress_type=zipfile.ZIP_STORED)

            for root_dir, dirs, files in os.walk(temp_dir):
                for file in files:
                    file_path = os.path.join(root_dir, file)
                    arcname = os.path.relpath(file_path, temp_dir)
                    if arcname != 'mimetype':
                        zip_out.write(file_path, arcname)

    return True


def main():
    parser = argparse.ArgumentParser(description='Update EPUB metadata (title, author, publisher)')
    parser.add_argument('epub_files', nargs='*', help='EPUB files to process')
    parser.add_argument('-t', '--title', nargs='?', const='', help='New title (use without value to set title to filename)')
    parser.add_argument('-a', '--author', help='New author')
    parser.add_argument('-p', '--publisher', help='New publisher')
    parser.add_argument('--show', action='store_true', help='Display current metadata without modifying')

    args = parser.parse_args()

    # If --show flag is set OR no modification flags provided, display metadata
    show_mode = args.show or (args.title is None and not args.author and not args.publisher)

    if show_mode:
        if args.epub_files:
            epub_files = [arg for arg in args.epub_files if arg.lower().endswith('.epub')]
            if not epub_files:
                print("Error: No EPUB files specified")
                sys.exit(1)
        else:
            print("Showing metadata for all epub files in current directory...\n")
            epub_files = sorted([f for f in os.listdir('.') if f.lower().endswith('.epub')])
            if not epub_files:
                print("No epub files found")
                sys.exit(0)

        for epub_file in epub_files:
            print(f"File: {epub_file}")
            if os.path.exists(epub_file):
                show_metadata(epub_file)
            else:
                print(f"  Error: File not found")
            print()
        return

    if args.epub_files:
        epub_files = [arg for arg in args.epub_files if arg.lower().endswith('.epub')]
        if not epub_files:
            print("Error: No EPUB files specified")
            sys.exit(1)
    else:
        print("Processing all epub files in current directory...\n")
        epub_files = sorted([f for f in os.listdir('.') if f.lower().endswith('.epub')])

    if not epub_files:
        print("No epub files found")
        sys.exit(0)

    for epub_file in epub_files:
        print(f"Processing: {epub_file}")

        # Determine what to update
        # If -t flag used without value (empty string), use filename as title
        if args.title == '':
            title_to_use = Path(epub_file).stem
        elif args.title:
            title_to_use = args.title
        else:
            title_to_use = None

        if title_to_use:
            print(f"Setting title to: {title_to_use}")
        if args.author:
            print(f"Setting author to: {args.author}")
        if args.publisher:
            print(f"Setting publisher to: {args.publisher}")

        if os.path.exists(epub_file):
            update_metadata(epub_file, title_to_use, args.author, args.publisher)
        else:
            print(f"  Error: File not found")
        print()

    print("Done processing all epub files!")


if __name__ == '__main__':
    main()
