#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.9"
# dependencies = [
#     "pillow",
#     "pypdf2",
# ]
# ///
"""
Simple Image-to-PDF Converter with Auto-Numbering

This script:
1. Scans all subdirectories for images
2. Flattens images into a "pages" folder with renamed files (e.g., 07/029.png -> pages/07_029.png)
3. Waits for user to press Enter before converting to PDF
4. Extracts numbers from directory names (e.g., "Chapter 3" -> "3.pdf")
5. Creates PDFs in the working directory
6. Moves processed directories to a "processed" folder
7. Interactively creates volumes by specifying chapter ranges
"""

import os
import re
import shutil
from pathlib import Path
from PIL import Image
from PyPDF2 import PdfMerger


def extract_number(dirname):
    """Extract number from directory name (e.g., 'Chapter 3' -> '3', '3.1' -> '3.1')"""
    # Match patterns like: 3, 3.1, 3.16, Chapter 3, Ch3, etc.
    match = re.search(r'(\d+(?:\.\d+)?)', dirname)
    if match:
        return match.group(1)
    return None


def natural_sort_key(s):
    """Sort strings with numbers naturally"""
    parts = re.split(r'(\d+)', str(s))
    return [int(p) if p.isdigit() else p.lower() for p in parts]


def get_images(directory):
    """Get all image files from a directory"""
    extensions = {'.jpg', '.jpeg', '.png', '.bmp', '.tiff', '.tif', '.gif', '.webp'}
    images = []

    for file in sorted(Path(directory).iterdir(), key=lambda x: natural_sort_key(x.name)):
        if file.is_file() and file.suffix.lower() in extensions:
            images.append(file)

    return images


def flatten_images_to_pages(base_path):
    """Flatten all images from subdirectories into a single 'pages' folder"""
    base_path = Path(base_path)
    pages_dir = base_path / "pages"
    
    # Create pages directory
    if pages_dir.exists():
        shutil.rmtree(pages_dir)
    pages_dir.mkdir()
    
    # Get all subdirectories
    subdirs = [d for d in base_path.iterdir() 
               if d.is_dir() 
               and not d.name.startswith('.') 
               and d.name not in ('processed', 'pages')]
    
    if not subdirs:
        print("No directories found to process.")
        return None
    
    # Sort naturally
    subdirs.sort(key=lambda x: natural_sort_key(x.name))
    
    print("\nFlattening images into 'pages' folder:\n")
    
    total_copied = 0
    dir_mapping = {}  # Maps directory number to list of image files in pages folder
    
    for subdir in subdirs:
        # Extract number from directory name
        number = extract_number(subdir.name)
        if not number:
            print(f"⊘ {subdir.name} - No number found, skipping")
            continue
        
        # Get images
        images = get_images(subdir)
        if not images:
            print(f"⊘ {subdir.name} - No images found, skipping")
            continue
        
        print(f"→ {subdir.name} ({len(images)} images)")
        
        # Copy images with new naming scheme
        copied_files = []
        for img_file in images:
            # New name: dirNumber_filename.ext (e.g., 07_029.png)
            new_name = f"{number}_{img_file.name}"
            dest_path = pages_dir / new_name
            
            shutil.copy2(img_file, dest_path)
            copied_files.append(dest_path)
            total_copied += 1
        
        dir_mapping[number] = copied_files
    
    print(f"\n✓ Copied {total_copied} images to pages/ folder")
    return dir_mapping


def images_to_pdf(image_files, output_pdf):
    """Convert images to PDF without quality loss"""
    if not image_files:
        return False

    images = []
    for img_path in image_files:
        try:
            img = Image.open(img_path)

            # Convert to RGB
            if img.mode in ('RGBA', 'LA', 'P'):
                rgb_img = Image.new('RGB', img.size, (255, 255, 255))
                if img.mode == 'P':
                    img = img.convert('RGBA')
                rgb_img.paste(img, mask=img.split()[-1] if img.mode in ('RGBA', 'LA') else None)
                img = rgb_img
            elif img.mode != 'RGB':
                img = img.convert('RGB')

            images.append(img)
        except Exception as e:
            print(f"  Error with {img_path.name}: {e}")

    if not images:
        return False

    try:
        images[0].save(
            output_pdf,
            save_all=True,
            append_images=images[1:],
            quality=100,
            optimize=False,
            resolution=300.0
        )
        return True
    except Exception as e:
        print(f"  Error creating PDF: {e}")
        return False


def process_directories(base_path, dir_mapping):
    """Process directories and create PDFs from flattened images"""
    base_path = Path(base_path)
    processed_dir = base_path / "processed"
    pages_dir = base_path / "pages"

    pdf_list = []
    print("\nCreating PDFs:\n")

    for number, image_files in sorted(dir_mapping.items(), key=lambda x: natural_sort_key(x[0])):
        # Create PDF with just the number
        pdf_name = f"{number}.pdf"
        pdf_path = base_path / pdf_name

        print(f"→ {number}.pdf ({len(image_files)} images)")

        if images_to_pdf(image_files, pdf_path):
            pdf_list.append((number, pdf_path))
            print(f"  ✓ Created {pdf_name}")
        else:
            print(f"  ✗ Failed to create {pdf_name}")

    # Move original directories to processed folder if PDFs were created
    if pdf_list:
        subdirs = [d for d in base_path.iterdir() 
                   if d.is_dir() 
                   and not d.name.startswith('.') 
                   and d.name not in ('processed', 'pages')]
        
        if subdirs:
            processed_dir.mkdir(exist_ok=True)
            for subdir in subdirs:
                dest = processed_dir / subdir.name
                
                # Handle existing directories
                if dest.exists():
                    shutil.rmtree(dest)
                
                shutil.move(str(subdir), str(dest))
            
            print(f"\n✓ Moved original directories to processed/")

    return pdf_list


def create_volumes(pdf_list, base_path):
    """Interactive volume creation"""
    if not pdf_list:
        print("\nNo PDFs to merge into volumes.")
        return

    base_path = Path(base_path)
    volume_num = 1
    last_num = None

    print("\n" + "=" * 60)
    print("CREATE VOLUMES")
    print("=" * 60)
    print("\nAvailable PDFs:")
    for i, (number, path) in enumerate(pdf_list, 1):
        print(f"  {i}. {number}.pdf")

    print("\nInstructions:")
    print("  Enter a range (e.g., '1-27' or '0.01-0.03') OR just the end number")
    print("  - Range with whole number end (e.g., '1-3'): Includes all decimals of end (1, 2, 3, 3.1, 3.5, etc.)")
    print("  - Range with decimal end (e.g., '0.01-0.03'): Stops exactly at that decimal")
    print("  - Single number: Auto-starts from next whole number after previous volume")
    print("  Type 'quit' to finish")
    print("=" * 60)

    while True:
        print(f"\n--- Volume {volume_num} ---")

        if volume_num == 1:
            inp = input("Enter range or end number: ").strip()
        else:
            # Calculate suggested start
            import math
            last_val = float(last_num)
            next_whole = math.floor(last_val) + 1

            # Check if this number exists
            has_next = any(float(num) >= next_whole for num, _ in pdf_list)

            if has_next:
                inp = input(f"Enter range or end number (auto-starts from {next_whole}): ").strip()
            else:
                print("No more PDFs available.")
                break

        if inp.lower() in ('quit', 'q', 'exit'):
            print("\nFinished!")
            break

        if not inp:
            print("Empty input. Type 'quit' to finish.")
            continue

        try:
            # Check if input is a range or single number
            if '-' in inp:
                # Range provided
                parts = inp.split('-')
                start_num = parts[0].strip()
                end_num = parts[1].strip()
            else:
                # Single number - calculate start
                if volume_num == 1:
                    print("For Volume 1, please enter a range (e.g., '1-27' or '0.01-0.03')")
                    continue

                import math
                last_val = float(last_num)
                start_num = str(math.floor(last_val) + 1)
                end_num = inp.strip()

            # Convert to floats for comparison
            try:
                start_val = float(start_num)
                end_val = float(end_num)
            except ValueError:
                print("Invalid numbers entered.")
                continue

            # Determine if range should include all decimals of the end number
            # Only include decimals if the end number is a whole number
            import math
            end_is_whole = (end_val == math.floor(end_val))

            # Find all PDFs within the range
            selected = []

            if end_is_whole:
                # End is a whole number - include all its decimals
                end_whole = int(end_val)

                for number, pdf_path in pdf_list:
                    try:
                        num_val = float(number)
                        num_whole = math.floor(num_val)

                        # Include if:
                        # 1. Between start and end (exclusive of end)
                        # 2. OR it's the end whole number or any decimal of it
                        if start_val <= num_val < end_whole:
                            selected.append((number, pdf_path))
                        elif num_whole == end_whole:
                            selected.append((number, pdf_path))
                    except ValueError:
                        continue
            else:
                # End is a decimal - stop exactly at that value
                for number, pdf_path in pdf_list:
                    try:
                        num_val = float(number)
                        if start_val <= num_val <= end_val:
                            selected.append((number, pdf_path))
                    except ValueError:
                        continue

            if not selected:
                print(f"No PDFs found in range {start_num} to {end_num}")
                available = [num for num, _ in pdf_list]
                print(f"Available PDF numbers: {', '.join(available)}")
                continue

            # Show selection
            print(f"\nVolume {volume_num} includes:")
            for num, _ in selected:
                print(f"  - {num}.pdf")

            # Merge PDFs (no confirmation needed)
            merger = PdfMerger()
            for _, pdf_path in selected:
                merger.append(str(pdf_path))

            volume_path = base_path / f"Volume_{volume_num}.pdf"
            merger.write(str(volume_path))
            merger.close()

            print(f"✓ Created Volume_{volume_num}.pdf")
            last_num = end_num
            volume_num += 1

        except ValueError:
            print("Invalid input. Enter numbers only.")
        except Exception as e:
            print(f"Error: {e}")


def main():
    import sys

    if len(sys.argv) > 1:
        base_path = sys.argv[1]
    else:
        base_path = '.'

    base_path = Path(base_path)

    print("=" * 60)
    print("IMAGE TO PDF CONVERTER")
    print("=" * 60)
    print(f"Working directory: {base_path.resolve()}\n")

    # Check if there are existing PDFs with numeric names
    existing_pdfs = []
    for file in base_path.iterdir():
        if file.is_file() and file.suffix == '.pdf' and file.name.startswith(('0','1','2','3','4','5','6','7','8','9')):
            # Extract number from filename
            match = re.match(r'^(\d+(?:\.\d+)?)\.pdf$', file.name)
            if match:
                number = match.group(1)
                existing_pdfs.append((number, file))

    # Sort existing PDFs
    existing_pdfs.sort(key=lambda x: float(x[0]))

    # Check for directories with images
    subdirs = [d for d in base_path.iterdir() 
               if d.is_dir() 
               and not d.name.startswith('.') 
               and d.name not in ('processed', 'pages')]

    has_image_dirs = False
    for subdir in subdirs:
        if get_images(subdir):
            has_image_dirs = True
            break

    pdf_list = []

    if has_image_dirs:
        # Step 1: Flatten images to pages folder
        print("Found directories with images. Flattening to pages/ folder...\n")
        dir_mapping = flatten_images_to_pages(base_path)
        
        if not dir_mapping:
            print("\nNo images to process.")
            return
        
        # Step 2: Wait for user to press Enter
        print("\n" + "=" * 60)
        print("Images have been copied to the 'pages/' folder.")
        print("You can now manually edit any images before PDF conversion.")
        print("=" * 60)
        input("\nPress ENTER when ready to convert to PDF...")
        
        # Step 3: Process and create PDFs
        pdf_list = process_directories(base_path, dir_mapping)

        if not pdf_list:
            print("\nNo PDFs created.")
            return

        print(f"\n✓ Created {len(pdf_list)} PDFs")

    elif existing_pdfs:
        # Skip to volume creation with existing PDFs
        print("No directories with images found.")
        print(f"Found {len(existing_pdfs)} existing PDFs. Skipping to volume creation.\n")
        pdf_list = existing_pdfs

    else:
        print("No directories with images or existing PDFs found.")
        return

    # Step 4: Create volumes
    create_volumes(pdf_list, base_path)


if __name__ == "__main__":
    main()
