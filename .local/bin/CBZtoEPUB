#!/usr/bin/env -S uv run --quiet --script
# /// script
# dependencies = [
#   "pillow>=10.0.0",
# ]
# ///
"""
Convert CBZ manga files to EPUB format with automatic two-page spread detection and splitting.
Maintains right-to-left reading direction for manga.
"""

import os
import zipfile
import shutil
from pathlib import Path
from PIL import Image
import xml.etree.ElementTree as ET
from datetime import datetime
import re


class MangaEPUBConverter:
    def __init__(self, cbz_path, output_dir=".", author="Tarō Hitsuji", publisher="Seven Seas"):
        self.cbz_path = Path(cbz_path)
        self.output_dir = Path(output_dir)
        self.author = author
        self.publisher = publisher

        # Extract title from filename (remove .cbz extension)
        self.title = self.cbz_path.stem

        # Create working directory
        self.work_dir = self.output_dir / f"{self.title}_work"
        self.work_dir.mkdir(exist_ok=True)

    def extract_cbz(self):
        """Extract CBZ file (it's just a ZIP file)"""
        print(f"Extracting {self.cbz_path.name}...")
        extract_dir = self.work_dir / "extracted"
        extract_dir.mkdir(exist_ok=True)

        with zipfile.ZipFile(self.cbz_path, 'r') as zip_ref:
            zip_ref.extractall(extract_dir)

        return extract_dir

    def get_image_files(self, directory):
        """Get all image files sorted by name"""
        image_extensions = {'.jpg', '.jpeg', '.png', '.gif', '.webp'}
        images = []

        for root, dirs, files in os.walk(directory):
            for file in files:
                if Path(file).suffix.lower() in image_extensions:
                    images.append(Path(root) / file)

        # Sort naturally (handles numbers correctly)
        def natural_sort_key(path):
            return [int(text) if text.isdigit() else text.lower()
                    for text in re.split(r'(\d+)', str(path.name))]

        return sorted(images, key=natural_sort_key)

    def process_images(self, image_files):
        """Process images: detect spreads and split them right-to-left"""
        print(f"Processing {len(image_files)} images...")

        image_dir = self.work_dir / "item" / "image"
        image_dir.mkdir(parents=True, exist_ok=True)

        processed_images = []
        page_num = 0

        for idx, img_path in enumerate(image_files):
            img = Image.open(img_path)
            width, height = img.size

            # Check if this is a two-page spread (width > height)
            if width > height:
                print(f"  Detected spread: {img_path.name} ({width}x{height})")
                # Split into two pages (right-to-left reading)
                mid = width // 2

                # Right page comes first (manga reading direction)
                right_page = img.crop((mid, 0, width, height))
                right_filename = f"i-{page_num:03d}.jpg"
                right_page.save(image_dir / right_filename, "JPEG", quality=90, optimize=True)
                processed_images.append((right_filename, right_page.size))
                page_num += 1

                # Left page comes second
                left_page = img.crop((0, 0, mid, height))
                left_filename = f"i-{page_num:03d}.jpg"
                left_page.save(image_dir / left_filename, "JPEG", quality=90, optimize=True)
                processed_images.append((left_filename, left_page.size))
                page_num += 1
            else:
                # Single page - just copy the original file instead of re-encoding
                filename = f"i-{page_num:03d}.jpg"

                # For JPEG files, copy directly to preserve quality and compression
                if img_path.suffix.lower() in {'.jpg', '.jpeg'}:
                    shutil.copy(img_path, image_dir / filename)
                    processed_images.append((filename, img.size))
                else:
                    # Convert non-JPEG to JPEG
                    if img.mode != 'RGB':
                        img = img.convert('RGB')
                    img.save(image_dir / filename, "JPEG", quality=90, optimize=True)
                    processed_images.append((filename, img.size))

                page_num += 1

            img.close()

        # First image is the cover
        if processed_images:
            cover_src = image_dir / processed_images[0][0]
            cover_dst = image_dir / "cover.jpg"
            shutil.copy(cover_src, cover_dst)

        print(f"  Generated {len(processed_images)} pages")
        return processed_images

    def create_epub_structure(self, processed_images):
        """Create EPUB directory structure"""
        print("Creating EPUB structure...")

        # Create directories
        (self.work_dir / "META-INF").mkdir(exist_ok=True)
        (self.work_dir / "item" / "xhtml").mkdir(parents=True, exist_ok=True)
        (self.work_dir / "item" / "style").mkdir(parents=True, exist_ok=True)

        # Create mimetype file (must be first and uncompressed)
        with open(self.work_dir / "mimetype", "w") as f:
            f.write("application/epub+zip")

        # Create container.xml
        self.create_container_xml()

        # Create CSS
        self.create_css()

        # Create XHTML files for each page
        self.create_xhtml_files(processed_images)

        # Create OPF file
        self.create_opf(processed_images)

        # Create NCX file
        self.create_ncx(processed_images)

        # Create nav.xhtml
        self.create_nav_xhtml(processed_images)

    def create_container_xml(self):
        """Create META-INF/container.xml"""
        content = '''<?xml version="1.0"?>
<container version="1.0" xmlns="urn:oasis:names:tc:opendocument:xmlns:container">
  <rootfiles>
    <rootfile full-path="item/comic.opf"
      media-type="application/oebps-package+xml" />
  </rootfiles>
</container>'''

        with open(self.work_dir / "META-INF" / "container.xml", "w") as f:
            f.write(content)

    def create_css(self):
        """Create fixed-layout.css"""
        content = '''@charset "UTF-8";
html, body { width: 100%; height: 100%; margin: 0; padding: 0; font-size: 0; }
svg { margin: 0; padding: 0; }
img { margin: 0; padding: 0; border: 0; }
p { display: none; }'''

        with open(self.work_dir / "item" / "style" / "fixed-layout.css", "w") as f:
            f.write(content)

    def create_xhtml_files(self, processed_images):
        """Create XHTML file for each page"""
        # Get dimensions from first page (assuming all pages are similar)
        if processed_images:
            _, (width, height) = processed_images[0]
        else:
            width, height = 1801, 2560

        # Cover page
        self.create_xhtml_page("cover", "../image/cover.jpg", width, height, is_cover=True)

        # Regular pages
        for idx, (img_filename, (img_width, img_height)) in enumerate(processed_images):
            page_id = f"p-{idx:03d}"
            self.create_xhtml_page(page_id, f"../image/{img_filename}", img_width, img_height)

    def create_xhtml_page(self, page_id, image_path, width, height, is_cover=False):
        """Create a single XHTML page"""
        filename = "cover.xhtml" if is_cover else f"{page_id}.xhtml"

        content = f'''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>{self.title}</title>
    <meta name="viewport" content="width={width}, height={height}"/>
    <link rel="stylesheet" type="text/css" href="../style/fixed-layout.css"/>
  </head>
  <body>
    <svg xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink" width="100%" height="100%" viewBox="0 0 {width} {height}">
      <image width="{width}" height="{height}" xlink:href="{image_path}"/>
    </svg>
  </body>
</html>'''

        with open(self.work_dir / "item" / "xhtml" / filename, "w") as f:
            f.write(content)

    def create_opf(self, processed_images):
        """Create comic.opf file"""
        if processed_images:
            _, (width, height) = processed_images[0]
        else:
            width, height = 1801, 2560

        timestamp = datetime.now().strftime("%Y-%m-%dT%H:%M:%SZ")

        # Start building OPF
        lines = [
            '<?xml version="1.0" encoding="UTF-8"?>',
            '<package xmlns="http://www.idpf.org/2007/opf" version="3.0" xml:lang="en" prefix="fixed-layout-jp: http://www.digital-comic.jp ibooks: http://vocabulary.itunes.apple.com/rdf/ibooks/vocabulary-extensions-1.0/" unique-identifier="pub-id" dir="rtl">',
            '  <metadata xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:epub="http://www.idpf.org/2011/epub">',
            f'    <dc:title id="id">{self.title}</dc:title>',
            f'    <dc:creator id="creator">{self.author}</dc:creator>',
            f'    <dc:identifier id="pub-id">urn:uuid:{self.title}</dc:identifier>',
            '    <dc:language>en</dc:language>',
            f'    <dc:date>{timestamp}</dc:date>',
            f'    <dc:publisher>{self.publisher}</dc:publisher>',
            '    <meta refines="#id" property="title-type">main</meta>',
            f'    <meta refines="#id" property="file-as">{self.title}</meta>',
            '    <meta refines="#pub-id" property="identifier-type" scheme="xsd:string">uuid</meta>',
            '    <meta refines="#creator" property="role" scheme="marc:relators">aut</meta>',
            f'    <meta refines="#creator" property="file-as">{self.author.upper()}</meta>',
            f'    <meta property="dcterms:modified">{timestamp}</meta>',
            '    <meta name="cover" content="cover-img"/>',
            '    <meta name="zero-gutter" content="true"/>',
            '    <meta name="zero-margin" content="true"/>',
            '    <meta name="RegionMagnification" content="false"/>',
            '    <meta name="SpineColor" content="#FFFFFF"/>',
            '    <meta name="fixed-layout" content="true"/>',
            '    <meta name="orientation-lock" content="none"/>',
            f'    <meta name="original-resolution" content="{width}x{height}"/>',
            '    <meta name="book-type" content="comic"/>',
            '    <meta name="primary-writing-mode" content="horizontal-rl"/>',
            f'    <meta property="fixed-layout-jp:viewport">width={width}, height={height}</meta>',
            '    <meta property="ibooks:binding">false</meta>',
            '    <meta property="rendition:layout">pre-paginated</meta>',
            '    <meta property="rendition:orientation">auto</meta>',
            '    <meta property="rendition:spread">landscape</meta>',
            '  </metadata>',
            '  <manifest>',
            '    <item id="cover" href="xhtml/cover.xhtml" media-type="application/xhtml+xml" fallback="cover-img" properties="svg"/>',
        ]

        # Add page items
        for idx in range(len(processed_images)):
            lines.append(f'    <item id="page-{idx:03d}" href="xhtml/p-{idx:03d}.xhtml" media-type="application/xhtml+xml" fallback="page-img-{idx:03d}" properties="svg"/>')

        # Add navigation and style items
        lines.extend([
            '    <item properties="nav" id="toc" href="nav.xhtml" media-type="application/xhtml+xml"/>',
            '    <item id="ncx" href="nav.ncx" media-type="application/x-dtbncx+xml"/>',
            '    <item id="css" href="style/fixed-layout.css" media-type="text/css"/>',
            '    <item id="cover-img" href="image/cover.jpg" properties="cover-image" media-type="image/jpeg"/>',
        ])

        # Add image items
        for idx, (img_filename, _) in enumerate(processed_images):
            lines.append(f'    <item id="page-img-{idx:03d}" href="image/{img_filename}" media-type="image/jpeg"/>')

        lines.extend([
            '  </manifest>',
            '  <spine toc="ncx" page-progression-direction="rtl">',
            '    <itemref linear="yes" idref="cover" properties="rendition:page-spread-center"/>',
        ])

        # Add spine items (alternating right/left pages)
        for idx in range(len(processed_images)):
            spread = "page-spread-right" if idx % 2 == 0 else "page-spread-left"
            lines.append(f'    <itemref linear="yes" idref="page-{idx:03d}" properties="{spread}"/>')

        lines.extend([
            '  </spine>',
            '</package>',
        ])

        with open(self.work_dir / "item" / "comic.opf", "w") as f:
            f.write('\n'.join(lines))

    def create_ncx(self, processed_images):
        """Create nav.ncx file"""
        content = f'''<?xml version="1.0" encoding="UTF-8"?>
<ncx xmlns="http://www.daisy.org/z3986/2005/ncx/" version="2005-1">
  <head>
    <meta name="dtb:uid" content="urn:uuid:{self.title}"/>
    <meta name="dtb:depth" content="1"/>
    <meta name="dtb:totalPageCount" content="0"/>
    <meta name="dtb:maxPageNumber" content="0"/>
  </head>
  <docTitle>
    <text>{self.title}</text>
  </docTitle>
  <navMap>
    <navPoint id="cover">
      <navLabel>
        <text>Cover</text>
      </navLabel>
      <content src="xhtml/cover.xhtml"/>
    </navPoint>
  </navMap>
</ncx>'''

        with open(self.work_dir / "item" / "nav.ncx", "w") as f:
            f.write(content)

    def create_nav_xhtml(self, processed_images):
        """Create nav.xhtml file"""
        content = f'''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>{self.title}</title>
  </head>
  <body>
    <nav epub:type="toc" id="toc">
      <h1>Table of Contents</h1>
      <ol>
        <li><a href="xhtml/cover.xhtml">Cover</a></li>
      </ol>
    </nav>
    <nav epub:type="landmarks">
      <h1>Landmarks</h1>
      <ol>
        <li><a epub:type="cover" href="xhtml/cover.xhtml">Cover</a></li>
      </ol>
    </nav>
  </body>
</html>'''

        with open(self.work_dir / "item" / "nav.xhtml", "w") as f:
            f.write(content)

    def package_epub(self):
        """Package the EPUB file"""
        print("Packaging EPUB...")

        epub_path = self.output_dir / f"{self.title}.epub"

        # Remove existing EPUB if it exists
        if epub_path.exists():
            epub_path.unlink()

        # Create ZIP file (EPUB is just a ZIP with specific structure)
        with zipfile.ZipFile(epub_path, 'w', zipfile.ZIP_DEFLATED) as epub:
            # mimetype must be first and uncompressed
            epub.write(self.work_dir / "mimetype", "mimetype", compress_type=zipfile.ZIP_STORED)

            # Add all other files
            for root, dirs, files in os.walk(self.work_dir):
                for file in files:
                    if file == "mimetype":
                        continue

                    file_path = Path(root) / file
                    arcname = file_path.relative_to(self.work_dir)
                    epub.write(file_path, arcname)

        print(f"Created: {epub_path}")
        return epub_path

    def cleanup(self):
        """Remove working directory"""
        if self.work_dir.exists():
            shutil.rmtree(self.work_dir)

    def convert(self, cleanup=True):
        """Main conversion process"""
        try:
            # Extract CBZ
            extracted_dir = self.extract_cbz()

            # Get and process images
            image_files = self.get_image_files(extracted_dir)
            if not image_files:
                print(f"No images found in {self.cbz_path}")
                return None

            processed_images = self.process_images(image_files)

            # Create EPUB structure
            self.create_epub_structure(processed_images)

            # Package EPUB
            epub_path = self.package_epub()

            # Cleanup
            if cleanup:
                self.cleanup()

            return epub_path

        except Exception as e:
            print(f"Error converting {self.cbz_path}: {e}")
            import traceback
            traceback.print_exc()
            return None


def main():
    """Convert all CBZ files in current directory or a specific file"""
    import sys

    current_dir = Path.cwd()

    # Check if specific file provided as argument
    if len(sys.argv) > 1:
        cbz_files = [Path(sys.argv[1])]
        if not cbz_files[0].exists():
            print(f"Error: File not found: {sys.argv[1]}")
            return
    else:
        cbz_files = sorted(current_dir.glob("*.cbz"))

    if not cbz_files:
        print("No CBZ files found")
        return

    print(f"Found {len(cbz_files)} CBZ file(s) to convert\n")

    successful = 0
    failed = 0

    for cbz_file in cbz_files:
        print(f"\n{'='*60}")
        print(f"Processing: {cbz_file.name}")
        print(f"{'='*60}")

        converter = MangaEPUBConverter(
            cbz_file,
            output_dir=current_dir,
            author="Tarō Hitsuji",
            publisher="Seven Seas"
        )

        result = converter.convert(cleanup=True)

        if result:
            successful += 1
        else:
            failed += 1

    print(f"\n{'='*60}")
    print(f"Conversion complete!")
    print(f"Successful: {successful}")
    print(f"Failed: {failed}")
    print(f"{'='*60}")


if __name__ == "__main__":
    main()
