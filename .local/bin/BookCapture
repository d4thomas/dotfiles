#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.10"
# dependencies = [
#     "mss",
#     "pillow",
#     "pynput",
# ]
# ///
"""
Screenshot capture script for Mac with image processing
c: Capture Pages (using mss for direct screenshot)
p: Process Pages

Usage:
  BookCapture [--ltr] [--single] [--no-cover]
  BookCapture --help

Options:
  --ltr       Use left-to-right mode (changes arrow key to Left and reverses page processing)
              Default is right-to-left mode
  --single    Treat all captures as single pages (no spread splitting)
  --no-cover  Treat first page as a spread (two pages) instead of a single cover page
  --help      Show this help message and exit
"""

from mss import mss
import time
from PIL import Image
import os
from pathlib import Path
import zipfile
import shutil
from pynput.keyboard import Key, Listener
from pynput import mouse
import sys
import re

# SET YOUR CAPTURE REGION HERE
# Format: {"top": y, "left": x, "width": w, "height": h}
CAPTURE_REGION = {'top': 53.48046875, 'left': 411.1484375, 'width': 2186.140625, 'height': 1638.5}

# Handle --help
if '--help' in sys.argv:
    print(__doc__)
    sys.exit(0)

# Global flags
RTL_MODE = '--ltr' not in sys.argv
SINGLE_PAGE_MODE = '--single' in sys.argv
NO_COVER_MODE = '--no-cover' in sys.argv

def capture_screenshot(output_path="screenshot.png"):
    """
    Capture a screenshot of the defined region.
    """
    with mss() as sct:
        screenshot = sct.grab(CAPTURE_REGION)
        # Convert to PIL Image and save
        img = Image.frombytes('RGB', screenshot.size, screenshot.rgb)
        img.save(output_path)
        print(f"Screenshot saved: {output_path}")
    return True

def wait_for_navigation():
    """
    Wait for user to press left arrow key, then continue.
    """
    print("Press LEFT ARROW to navigate to next page...")

    pressed = {'done': False}

    def on_press(key):
        if key == Key.left:
            pressed['done'] = True
            return False  # Stop listener

    with Listener(on_press=on_press) as listener:
        listener.join()

    print("Navigating to next page...")
    time.sleep(0.5)  # Small delay after navigation

def press_arrow_and_wait():
    """
    Simulate pressing arrow key (left or right depending on mode) and wait 2.5 seconds.
    """
    from pynput.keyboard import Controller
    keyboard = Controller()

    # RTL: press LEFT to go forward (next page)
    # LTR: press RIGHT to go forward (next page)
    arrow_key = Key.left if RTL_MODE else Key.right
    arrow_name = "LEFT" if RTL_MODE else "RIGHT"

    print(f"Pressing {arrow_name} ARROW...")
    keyboard.press(arrow_key)
    keyboard.release(arrow_key)

    print("Waiting 2.5 seconds...")
    time.sleep(2.5)

def wait_for_mouse_click():
    """
    Wait for user to click the mouse in the capture window.
    """
    print("Click in the capture window to start capturing...")

    clicked = {'done': False}

    def on_click(x, y, button, pressed):
        if pressed and button == mouse.Button.left:
            clicked['done'] = True
            print("✓ Click detected! Starting capture...")
            return False  # Stop listener

    with mouse.Listener(on_click=on_click) as listener:
        listener.join()

def find_coordinates():
    """
    Interactive coordinate finder - click two corners to get region coordinates.
    Updates the script file automatically with the new region.
    """
    global CAPTURE_REGION

    print("\n" + "=" * 50)
    print("FIND SCREEN COORDINATES")
    print("=" * 50)
    print("\nInstructions:")
    print("1. Click the TOP-LEFT corner of the region to capture")
    print("2. Click the BOTTOM-RIGHT corner of the region to capture")
    print("\nReady? Click the TOP-LEFT corner now...")

    clicks = []
    result = {'region': None}

    def on_click(x, y, button, pressed):
        if pressed and button == mouse.Button.left:
            clicks.append((x, y))
            if len(clicks) == 1:
                print(f"\n✓ Top-left corner: ({x}, {y})")
                print("\nNow click the BOTTOM-RIGHT corner...")
            elif len(clicks) == 2:
                print(f"✓ Bottom-right corner: ({x}, {y})")

                # Calculate region
                x1, y1 = clicks[0]
                x2, y2 = clicks[1]

                result['region'] = {
                    "top": min(y1, y2),
                    "left": min(x1, x2),
                    "width": abs(x2 - x1),
                    "height": abs(y2 - y1)
                }

                return False  # Stop listener

    with mouse.Listener(on_click=on_click) as listener:
        listener.join()

    if result['region']:
        region = result['region']
        print("\n" + "=" * 50)
        print("YOUR CAPTURE REGION:")
        print("=" * 50)
        print(f"\nCAPTURE_REGION = {region}")

        # Update the script file
        script_path = Path(__file__).resolve()
        content = script_path.read_text()
        new_line = f"CAPTURE_REGION = {region}"
        updated = re.sub(r"^CAPTURE_REGION = \{.*\}$", new_line, content, flags=re.MULTILINE)
        script_path.write_text(updated)

        # Update the global variable for current session
        CAPTURE_REGION = region

        print("\n✓ Script updated with new capture region!")
        print("=" * 50)

def process_images():
    """
    Process images:
    1. Find all PNG/JPG images in current directory
    2. Sort by filename
    3. In single-page mode: crop all images to center
    4. In spread mode: crop first image (single centered page), split remaining images (two-page spreads)
    """
    direction = "Right-to-Left" if RTL_MODE else "Left-to-Right"
    mode = "Single page" if SINGLE_PAGE_MODE else "Spread"
    cover_mode = "no cover (all spreads)" if NO_COVER_MODE else "with cover"
    print(f"\nUsing {direction} mode, {mode} processing, {cover_mode}...\n")

    # Get all image files (looking for screenshot files)
    image_extensions = ('.png', '.jpg', '.jpeg', '.PNG', '.JPG', '.JPEG')
    images = [f for f in os.listdir('.') if f.endswith(image_extensions) and 'screenshot_' in f]

    if not images:
        print("No images found in current directory!")
        return

    # Sort by filename (which includes timestamp and count)
    images.sort()
    print(f"Found {len(images)} images")
    print("Processing in this order:")
    for i, img in enumerate(images, 1):
        print(f"  {i}. {img}")

    # Create output directory
    output_dir = Path('processed')
    output_dir.mkdir(exist_ok=True)

    page_number = 1

    if SINGLE_PAGE_MODE:
        # Single page mode: just convert to JPG without cropping or splitting
        for idx, img_file in enumerate(images):
            print(f"Processing {img_file}...")
            img = Image.open(img_file)
            # Convert RGBA to RGB if needed
            if img.mode == 'RGBA':
                img = img.convert('RGB')

            output_path = output_dir / f"{page_number:03d}.jpg"
            img.save(output_path, 'JPEG', quality=85, optimize=True)
            print(f"  Saved page {page_number}")
            page_number += 1
    else:
        # Spread mode: crop and split images
        for idx, img_file in enumerate(images):
            print(f"Processing {img_file}...")
            img = Image.open(img_file)
            # Convert RGBA to RGB if needed
            if img.mode == 'RGBA':
                img = img.convert('RGB')
            width, height = img.size

            if idx == 0 and not NO_COVER_MODE:
                # First image - single page centered, crop to fit
                # Assuming the page is centered, crop to half width
                left = width // 4
                right = left + (width // 2)
                cropped = img.crop((left, 0, right, height))
                output_path = output_dir / f"{page_number:03d}.jpg"
                cropped.save(output_path, 'JPEG', quality=85, optimize=True)
                print(f"  Saved cropped single page as {output_path}")
                page_number += 1
            else:
                # Two-page spread - split into two images
                mid = width // 2

                left_half = img.crop((0, 0, mid, height))
                right_half = img.crop((mid, 0, width, height))

                if RTL_MODE:
                    # RTL: Right side of screen is read first, then left side
                    first_path = output_dir / f"{page_number:03d}.jpg"
                    right_half.save(first_path, 'JPEG', quality=85, optimize=True)
                    print(f"  Saved page {page_number} (right page)")
                    page_number += 1

                    second_path = output_dir / f"{page_number:03d}.jpg"
                    left_half.save(second_path, 'JPEG', quality=85, optimize=True)
                    print(f"  Saved page {page_number} (left page)")
                    page_number += 1
                else:
                    # LTR: Left side of screen = Left page (read first)
                    first_path = output_dir / f"{page_number:03d}.jpg"
                    left_half.save(first_path, 'JPEG', quality=85, optimize=True)
                    print(f"  Saved page {page_number} (left page)")
                    page_number += 1

                    second_path = output_dir / f"{page_number:03d}.jpg"
                    right_half.save(second_path, 'JPEG', quality=85, optimize=True)
                    print(f"  Saved page {page_number} (right page)")
                    page_number += 1

    print(f"\n✓ Processing complete! {page_number - 1} pages created")

    # Create CBZ file
    print("\nCreating CBZ archive...")
    current_dir_name = Path.cwd().name
    cbz_filename = f"{current_dir_name}.cbz"
    with zipfile.ZipFile(cbz_filename, 'w', zipfile.ZIP_DEFLATED) as cbz:
        # Add all processed JPGs to the CBZ in correct numerical order
        processed_files = sorted(output_dir.glob('*.jpg'), key=lambda x: x.name)
        for jpg_file in processed_files:
            cbz.write(jpg_file, jpg_file.name)
            print(f"  Added {jpg_file.name} to archive")

    print(f"✓ Created {cbz_filename}")

    # Move original captured images to a separate folder
    print("\nOrganizing original images...")
    originals_dir = Path('originals')
    originals_dir.mkdir(exist_ok=True)

    for img_file in images:
        src = Path(img_file)
        dst = originals_dir / img_file
        shutil.move(str(src), str(dst))
        print(f"  Moved {img_file} to originals/")

    # Remove the processed directory
    print(f"\nCleaning up {output_dir}/...")
    shutil.rmtree(output_dir)

    print("\n" + "=" * 50)
    print("All done!")
    print(f"Saved as: {cbz_filename}")
    print("=" * 50)

def run_capture():
    """Run the continuous capture automation"""
    print("=" * 50)
    print("SCREENSHOT CAPTURE MODE")
    print("=" * 50)
    print(f"Using capture region: {CAPTURE_REGION}")

    # Ask user for number of pages
    while True:
        try:
            total_pages = int(input("\nHow many pages to capture? "))
            if total_pages <= 0:
                print("Please enter a positive number.")
                continue
            break
        except ValueError:
            print("Please enter a valid number.")

    # Calculate number of captures needed
    if SINGLE_PAGE_MODE:
        # Single page mode: 1 capture = 1 page
        num_captures = total_pages
        print(f"\nTotal pages: {total_pages}")
        print(f"Number of captures: {num_captures}")
        print(f"  - All captures: 1 page each (single page mode)")
    elif NO_COVER_MODE:
        # No cover mode: all captures are spreads (2 pages each)
        # Formula: total_pages = num_captures * 2
        num_captures = (total_pages + 1) // 2
        print(f"\nTotal pages: {total_pages}")
        print(f"Number of captures: {num_captures}")
        print(f"  - All captures: 2 pages each (no cover mode)")
    else:
        # Spread mode: First capture = 1 page, remaining captures = 2 pages each
        # Formula: total_pages = 1 + (num_captures - 1) * 2
        # Solving: num_captures = (total_pages - 1) / 2 + 1 = (total_pages + 1) / 2
        num_captures = (total_pages + 1) // 2
        print(f"\nTotal pages: {total_pages}")
        print(f"Number of captures: {num_captures}")
        print(f"  - First capture: 1 page")
        if num_captures > 1:
            print(f"  - Remaining {num_captures - 1} captures: 2 pages each")

    print("\n" + "=" * 50)
    time.sleep(1)

    try:
        timestamp_base = time.strftime("%Y%m%d_%H%M%S")

        for count in range(1, num_captures + 1):
            print(f"\n--- Capture {count} of {num_captures} ---")

            # First capture waits for mouse click, then waits 2.5 seconds
            if count == 1:
                wait_for_mouse_click()
                print("Waiting 2.5 seconds...")
                time.sleep(2.5)

            # Generate filename
            filename = f"screenshot_{timestamp_base}_{count:03d}.png"

            # Capture screenshot
            if capture_screenshot(filename):
                print(f"✓ Captured screenshot {count}")
            else:
                print("Capture failed. Stopping...")
                break

            # If not the last capture, press arrow key and wait
            if count < num_captures:
                press_arrow_and_wait()

        print(f"\n✓ All {num_captures} captures completed!")

    except KeyboardInterrupt:
        print("\n\nCapture stopped. Returning to menu...")

if __name__ == "__main__":
    while True:
        print("\n" + "=" * 50)
        print("SCREENSHOT CAPTURE & PROCESSOR")
        print("=" * 50)
        print("\nMenu:")
        print("  c - Capture")
        print("  f - Find Coordinates")
        print("  p - Process Pages")
        print("  q - Quit")

        choice = input("Choice (c/f/p/q): ").strip().lower()

        if choice == 'c':
            run_capture()
        elif choice == 'f':
            find_coordinates()
        elif choice == 'p':
            process_images()
        elif choice == 'q':
            print("\nGoodbye!")
            break
        else:
            print("Invalid choice. Please choose 'c', 'f', 'p', or 'q'.")
