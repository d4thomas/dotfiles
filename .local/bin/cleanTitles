#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.9"
# dependencies = [
#     "ebooklib",
# ]
# ///
"""
Script to update EPUB book titles and sort titles based on filename.
Removes the .epub extension and uses the filename as both title and sort title.
"""

import os
import sys
from pathlib import Path
from ebooklib import epub
import argparse


def update_book_metadata(epub_path):
    """
    Update the title and sort title of an EPUB file based on its filename.

    Args:
        epub_path: Path to the EPUB file

    Returns:
        tuple: (success: bool, message: str)
    """
    try:
        # Get the new title from filename (without .epub extension)
        new_title = Path(epub_path).stem

        # Read the EPUB file
        book = epub.read_epub(epub_path)

        # Get current title for comparison
        old_title = book.get_metadata('DC', 'title')
        old_title_str = old_title[0][0] if old_title else "No title"

        # Update title and sort title
        book.set_title(new_title)

        # Remove existing sort title metadata if any
        book.metadata.setdefault('http://purl.org/dc/elements/1.1/', {})
        if 'title' in book.metadata['http://purl.org/dc/elements/1.1/']:
            # Clear and set new title
            book.metadata['http://purl.org/dc/elements/1.1/']['title'] = [(new_title, {})]

        # Set sort title using the calibre metadata namespace
        book.metadata.setdefault('http://calibre.kovidgoyal.net/2009/metadata', {})
        book.metadata['http://calibre.kovidgoyal.net/2009/metadata']['title_sort'] = [(new_title, {})]

        # Write the updated EPUB file
        epub.write_epub(epub_path, book)

        return True, f"✓ Updated: '{old_title_str}' → '{new_title}'"

    except Exception as e:
        return False, f"✗ Error processing {epub_path}: {str(e)}"


def process_directory(directory, recursive=False):
    """
    Process all EPUB files in a directory.

    Args:
        directory: Path to directory containing EPUB files
        recursive: Whether to search subdirectories
    """
    path = Path(directory)

    if not path.exists():
        print(f"Error: Directory '{directory}' does not exist")
        return

    # Find all EPUB files
    if recursive:
        epub_files = list(path.rglob("*.epub"))
    else:
        epub_files = list(path.glob("*.epub"))

    if not epub_files:
        print(f"No EPUB files found in '{directory}'")
        return

    print(f"Found {len(epub_files)} EPUB file(s)\n")

    success_count = 0
    error_count = 0

    for epub_file in epub_files:
        success, message = update_book_metadata(epub_file)
        print(message)

        if success:
            success_count += 1
        else:
            error_count += 1

    print(f"\nSummary: {success_count} successful, {error_count} errors")


def main():
    parser = argparse.ArgumentParser(
        description="Update EPUB book titles based on filenames",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Process all EPUB files in current directory
  python cleanTitles
  # Process all EPUB files in a specific directory
  python cleanTitles /path/to/books

  # Process all EPUB files recursively
  python cleanTitles /path/to/books --recursive

  # Process a single file
  python cleanTitles "BookName.epub"
        """
    )

    parser.add_argument(
        'path',
        nargs='?',
        default='.',
        help='Path to EPUB file or directory (default: current directory)'
    )

    parser.add_argument(
        '-r', '--recursive',
        action='store_true',
        help='Process subdirectories recursively'
    )

    args = parser.parse_args()
    path = Path(args.path)

    if path.is_file():
        if path.suffix.lower() == '.epub':
            success, message = update_book_metadata(path)
            print(message)
            sys.exit(0 if success else 1)
        else:
            print(f"Error: '{path}' is not an EPUB file")
            sys.exit(1)
    elif path.is_dir():
        process_directory(path, args.recursive)
    else:
        print(f"Error: '{path}' does not exist")
        sys.exit(1)


if __name__ == "__main__":
    main()
