#!/usr/bin/env -S uv run
# /// script
# requires-python = ">=3.8"
# dependencies = []
# ///
"""
Convert EPUB files to CBZ (Comic Book ZIP) format.
Extracts images from EPUB using the proper reading order from the spine.
"""

import argparse
import os
import zipfile
import tempfile
import shutil
import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Optional


def get_content_opf_path(epub_zip: zipfile.ZipFile) -> str:
    """Find the path to content.opf file from container.xml."""
    container_xml = epub_zip.read('META-INF/container.xml')
    root = ET.fromstring(container_xml)

    # Find the rootfile element
    ns = {'container': 'urn:oasis:names:tc:opendocument:xmlns:container'}
    rootfile = root.find('.//container:rootfile', ns)

    if rootfile is not None:
        return rootfile.get('full-path')

    # Fallback to common location
    return 'OEBPS/content.opf'


def parse_spine_order(epub_zip: zipfile.ZipFile) -> List[str]:
    """
    Parse the EPUB spine to get the proper reading order of images.

    Returns:
        List of image paths in reading order
    """
    # Get content.opf path
    try:
        opf_path = get_content_opf_path(epub_zip)
    except:
        opf_path = 'OEBPS/content.opf'

    opf_content = epub_zip.read(opf_path).decode('utf-8')
    root = ET.fromstring(opf_content)

    # Define OPF namespace
    ns = {'opf': 'http://www.idpf.org/2007/opf'}

    # If no namespace, try without it
    if root.find('.//opf:spine', ns) is None:
        ns = {}

    # Build manifest: id -> href mapping
    manifest = {}
    for item in root.findall('.//manifest/item' if not ns else './/opf:manifest/opf:item', ns):
        item_id = item.get('id')
        href = item.get('href')
        if item_id and href:
            manifest[item_id] = href

    # Get spine order
    spine_items = []
    spine = root.find('.//spine' if not ns else './/opf:spine', ns)

    if spine is not None:
        for itemref in spine.findall('itemref' if not ns else 'opf:itemref', ns):
            idref = itemref.get('idref')
            if idref and idref in manifest:
                spine_items.append(manifest[idref])

    return spine_items


def extract_images_from_xhtml(epub_zip: zipfile.ZipFile, xhtml_path: str, base_path: str) -> Optional[str]:
    """
    Extract image reference from an XHTML page.

    Args:
        epub_zip: The EPUB zip file
        xhtml_path: Path to the XHTML file
        base_path: Base path for resolving relative paths

    Returns:
        Path to the image file or None
    """
    try:
        xhtml_content = epub_zip.read(xhtml_path).decode('utf-8')
        root = ET.fromstring(xhtml_content)

        # Look for image tags (HTML img tags and SVG image tags)
        for elem in root.iter():
            # Check for HTML img tag
            if elem.tag.endswith('img'):
                src = elem.get('src')
                if src:
                    xhtml_dir = os.path.dirname(xhtml_path)
                    img_path = os.path.normpath(os.path.join(xhtml_dir, src))
                    return img_path

            # Check for SVG image tag with xlink:href
            if elem.tag.endswith('image'):
                # Try xlink:href with namespace
                href = elem.get('{http://www.w3.org/1999/xlink}href')
                if not href:
                    # Try without namespace
                    href = elem.get('href')
                if href:
                    xhtml_dir = os.path.dirname(xhtml_path)
                    img_path = os.path.normpath(os.path.join(xhtml_dir, href))
                    return img_path
    except Exception as e:
        pass

    return None


def extract_images_in_order(epub_path: str, temp_dir: str) -> List[str]:
    """
    Extract images from EPUB in the proper reading order based on spine.

    Args:
        epub_path: Path to the EPUB file
        temp_dir: Temporary directory to extract images to

    Returns:
        List of image paths in reading order
    """
    images = []
    seen_images = set()

    with zipfile.ZipFile(epub_path, 'r') as epub_zip:
        # Get spine order
        spine_items = parse_spine_order(epub_zip)

        if not spine_items:
            # Fallback: just extract all images sorted by name
            print("Warning: Could not parse spine, using filename sort order")
            for file_info in epub_zip.filelist:
                filename = file_info.filename.lower()
                if any(filename.endswith(ext) for ext in ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp']):
                    # Skip obvious duplicates like nested OEBPS/OEBPS
                    if '/oebps/' in filename.lower() and filename.lower().count('/oebps/') > 1:
                        continue
                    # Skip standalone cover files if we have page-001
                    if 'cover' in filename.lower() and not 'page' in filename.lower():
                        continue
                    source = epub_zip.extract(file_info.filename, temp_dir)
                    images.append(source)
            images.sort()
            return images

        # Get OPF directory for resolving relative paths
        try:
            opf_path = get_content_opf_path(epub_zip)
        except:
            opf_path = 'OEBPS/content.opf'
        opf_dir = os.path.dirname(opf_path)

        # Process spine items in order
        for spine_item in spine_items:
            # Spine items are relative to OPF location
            full_spine_path = os.path.normpath(os.path.join(opf_dir, spine_item))

            # For XHTML files, extract the image they reference
            if spine_item.endswith('.xhtml') or spine_item.endswith('.html'):
                base_path = os.path.dirname(full_spine_path)
                img_path = extract_images_from_xhtml(epub_zip, full_spine_path, base_path)

                if img_path and img_path not in seen_images:
                    try:
                        source = epub_zip.extract(img_path, temp_dir)
                        images.append(source)
                        seen_images.add(img_path)
                    except KeyError:
                        print(f"Warning: Could not find image {img_path}")
            # Direct image reference
            elif any(spine_item.lower().endswith(ext) for ext in ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp']):
                if full_spine_path not in seen_images:
                    try:
                        source = epub_zip.extract(full_spine_path, temp_dir)
                        images.append(source)
                        seen_images.add(full_spine_path)
                    except KeyError:
                        print(f"Warning: Could not find image {full_spine_path}")

    return images


def create_cbz_from_images(images: List[str], output_path: str) -> None:
    """
    Create a CBZ file from a list of image files.

    Args:
        images: List of image file paths
        output_path: Path for the output CBZ file
    """
    with zipfile.ZipFile(output_path, 'w', zipfile.ZIP_DEFLATED) as cbz:
        for idx, img_path in enumerate(images, 1):
            # Get the file extension
            ext = os.path.splitext(img_path)[1]
            # Create a simple numbered filename
            archive_name = f"{idx:04d}{ext}"
            cbz.write(img_path, archive_name)


def epub_to_cbz(epub_path: str, output_path: str = None) -> str:
    """
    Convert an EPUB file to CBZ format.

    Args:
        epub_path: Path to the input EPUB file
        output_path: Path for the output CBZ file (optional)

    Returns:
        Path to the created CBZ file
    """
    # Validate input file
    if not os.path.exists(epub_path):
        raise FileNotFoundError(f"EPUB file not found: {epub_path}")

    if not epub_path.lower().endswith('.epub'):
        raise ValueError("Input file must have .epub extension")

    # Determine output path
    if output_path is None:
        base_name = os.path.splitext(epub_path)[0]
        output_path = f"{base_name}.cbz"

    # Create temporary directory for extraction
    temp_dir = tempfile.mkdtemp()

    try:
        print(f"Extracting images from: {epub_path}")
        images = extract_images_in_order(epub_path, temp_dir)

        if not images:
            raise ValueError("No images found in the EPUB file")

        print(f"Found {len(images)} images")
        print(f"Creating CBZ file: {output_path}")

        create_cbz_from_images(images, output_path)

        print(f"âœ“ Successfully created: {output_path}")
        return output_path

    finally:
        # Clean up temporary directory
        shutil.rmtree(temp_dir, ignore_errors=True)


def main():
    parser = argparse.ArgumentParser(
        description="Convert EPUB files to CBZ (Comic Book ZIP) format",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s book.epub
  %(prog)s book.epub -o comic.cbz
  %(prog)s book.epub --output /path/to/output.cbz
        """
    )

    parser.add_argument(
        'epub_file',
        help='Path to the EPUB file to convert'
    )

    parser.add_argument(
        '-o', '--output',
        help='Output CBZ file path (default: same name as input with .cbz extension)',
        default=None
    )

    args = parser.parse_args()

    try:
        epub_to_cbz(args.epub_file, args.output)
    except Exception as e:
        print(f"Error: {e}")
        return 1

    return 0


if __name__ == '__main__':
    exit(main())
