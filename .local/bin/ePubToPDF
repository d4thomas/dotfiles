#!/usr/bin/env -S uv run --script
# /// script
# dependencies = [
#   "pillow",
# ]
# ///

import os
import sys
import zipfile
import tempfile
import subprocess
import re
import argparse
from pathlib import Path
from collections import Counter
import xml.etree.ElementTree as ET
from PIL import Image

def natural_sort_key(s):
    """Sort strings containing numbers naturally."""
    return [int(text) if text.isdigit() else text.lower()
            for text in re.split('([0-9]+)', str(s))]

def parse_filename(filename):
    """
    Parse filename to extract series name and volume number.
    Format: "Author - Series Name Volume# (extra) hash.epub"
    """
    # Remove .epub extension
    name = filename.replace('.epub', '')

    # Try to split by " - " to separate author from rest
    if ' - ' in name:
        parts = name.split(' - ', 1)
        rest = parts[1]
    else:
        rest = name

    # Extract volume number - look for digits at the end before any parentheses or hash
    # Remove hash pattern at the end (8 hex chars)
    rest = re.sub(r'\s+[a-f0-9]{8}$', '', rest)

    # Try to find volume number - looking for standalone number
    vol_match = re.search(r'\s+(\d+)\s*(?:\(|$)', rest)
    if vol_match:
        volume = int(vol_match.group(1))
        # Get series name (everything before the volume number)
        series_name = rest[:vol_match.start()].strip()
    else:
        # No volume number found, use entire rest as series name
        volume = None
        series_name = rest.strip()

    # Clean up series name - remove any trailing parenthetical content if no volume was found
    if volume is None:
        series_name = re.sub(r'\s*\([^)]*\)\s*$', '', series_name)

    return series_name, volume

def find_opf_file(temp_path):
    """Find the OPF file path from container.xml."""
    container_path = temp_path / 'META-INF' / 'container.xml'
    if not container_path.exists():
        opf_files = list(temp_path.rglob('*.opf'))
        if opf_files:
            return opf_files[0]
        return None

    tree = ET.parse(container_path)
    root = tree.getroot()

    ns = {'container': 'urn:oasis:names:tc:opendocument:xmlns:container'}
    rootfile = root.find('.//container:rootfile', ns)

    if rootfile is not None:
        opf_path = rootfile.get('full-path')
        return temp_path / opf_path
    return None

def get_ordered_images_from_opf(temp_path, opf_path):
    """Parse OPF file and extract images in spine order."""
    tree = ET.parse(opf_path)
    root = tree.getroot()

    ns = {
        'opf': 'http://www.idpf.org/2007/opf',
        'dc': 'http://purl.org/dc/elements/1.1/'
    }

    opf_dir = opf_path.parent

    # Build manifest dictionary (id -> href)
    manifest = {}
    for item in root.findall('.//opf:manifest/opf:item', ns):
        item_id = item.get('id')
        href = item.get('href')
        if item_id and href:
            manifest[item_id] = href

    if not manifest:
        for item in root.findall('.//manifest/item'):
            item_id = item.get('id')
            href = item.get('href')
            if item_id and href:
                manifest[item_id] = href

    # Get spine order
    spine_items = []
    for itemref in root.findall('.//opf:spine/opf:itemref', ns):
        idref = itemref.get('idref')
        if idref:
            spine_items.append(idref)

    if not spine_items:
        for itemref in root.findall('.//spine/itemref'):
            idref = itemref.get('idref')
            if idref:
                spine_items.append(idref)

    # Extract images in spine order
    ordered_images = []

    for spine_id in spine_items:
        if spine_id not in manifest:
            continue

        content_href = manifest[spine_id]
        content_path = opf_dir / content_href

        if not content_path.exists():
            continue

        try:
            content_tree = ET.parse(content_path)
            content_root = content_tree.getroot()

            img_ns = {'xhtml': 'http://www.w3.org/1999/xhtml'}
            imgs = content_root.findall('.//xhtml:img', img_ns)

            if not imgs:
                imgs = content_root.findall('.//img')

            for img in imgs:
                src = img.get('src')
                if src:
                    img_path = (content_path.parent / src).resolve()
                    if img_path.exists():
                        ordered_images.append(img_path)
        except Exception:
            continue

    return ordered_images

def get_normalized_page_size(image_paths):
    """Determine the page size to use for normalization."""
    sizes = []
    for img_path in image_paths:
        try:
            with Image.open(img_path) as img:
                sizes.append(img.size)
        except Exception:
            continue

    if not sizes:
        return None

    # Get the most common size
    size_counter = Counter(sizes)
    most_common_size = size_counter.most_common(1)[0][0]

    # Also check the maximum dimensions
    max_width = max(s[0] for s in sizes)
    max_height = max(s[1] for s in sizes)

    if most_common_size == (max_width, max_height):
        return most_common_size

    return (max_width, max_height)

def convert_epub_to_pdf(epub_path):
    """Convert an image-based EPUB to PDF."""
    epub_path = Path(epub_path)

    # Parse filename to get series name and volume
    series_name, volume = parse_filename(epub_path.name)

    # Create output filename
    if volume is not None:
        pdf_name = f"{series_name} Vol. {volume:02d}.pdf"
    else:
        pdf_name = f"{series_name}.pdf"

    pdf_path = epub_path.parent / pdf_name

    # Skip if PDF already exists
    if pdf_path.exists():
        print(f"Skipping {epub_path.name} - PDF already exists")
        return True

    print(f"Converting {epub_path.name}...")
    print(f"  Series: {series_name}")
    if volume is not None:
        print(f"  Volume: {volume}")
    print(f"  Output: {pdf_name}")

    # Create temporary directory
    with tempfile.TemporaryDirectory() as temp_dir:
        temp_path = Path(temp_dir)

        # Extract EPUB
        try:
            with zipfile.ZipFile(epub_path, 'r') as zip_ref:
                zip_ref.extractall(temp_path)
        except Exception as e:
            print(f"Error extracting {epub_path.name}: {e}")
            return False

        # Find OPF file
        opf_path = find_opf_file(temp_path)
        if not opf_path:
            print(f"Could not find OPF file in {epub_path.name}")
            return False

        # Get ordered images from OPF spine
        ordered_images = get_ordered_images_from_opf(temp_path, opf_path)

        if not ordered_images:
            print(f"No images found in {epub_path.name}")
            return False

        print(f"  Found {len(ordered_images)} images in reading order")

        # Determine normalized page size
        page_size = get_normalized_page_size(ordered_images)
        if page_size:
            target_width, target_height = page_size
            print(f"  Normalizing to page size: {target_width}x{target_height}px")

            # Create normalized images
            normalized_dir = temp_path / 'normalized'
            normalized_dir.mkdir(exist_ok=True)

            normalized_images = []
            for i, img_path in enumerate(ordered_images):
                try:
                    with Image.open(img_path) as img:
                        # Create a new image with the target size (white background)
                        new_img = Image.new('RGB', (target_width, target_height), 'white')

                        # Calculate position to center the original image
                        img_width, img_height = img.size

                        # Fit image into target size while maintaining aspect ratio
                        if img_width != target_width or img_height != target_height:
                            # Calculate scaling to fit
                            scale = min(target_width / img_width, target_height / img_height)
                            new_size = (int(img_width * scale), int(img_height * scale))
                            img = img.resize(new_size, Image.Resampling.LANCZOS)

                        # Center the image
                        paste_x = (target_width - img.size[0]) // 2
                        paste_y = (target_height - img.size[1]) // 2

                        new_img.paste(img, (paste_x, paste_y))

                        # Save normalized image
                        normalized_path = normalized_dir / f'page_{i:04d}.jpg'
                        new_img.save(normalized_path, 'JPEG', quality=95)
                        normalized_images.append(normalized_path)
                except Exception as e:
                    print(f"  Warning: Could not normalize image {img_path.name}: {e}")
                    normalized_images.append(img_path)

            image_paths = [str(img) for img in normalized_images]
        else:
            image_paths = [str(img) for img in ordered_images]

        # Convert to PDF using img2pdf
        try:
            cmd = ['img2pdf', '-o', str(pdf_path)] + image_paths

            subprocess.run(
                cmd,
                check=True,
                capture_output=True
            )
            print(f"Successfully created {pdf_name}")
            return True
        except subprocess.CalledProcessError as e:
            print(f"Error converting {epub_path.name}: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description='Convert EPUB files to PDF format',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Examples:
  %(prog)s                    # Convert all EPUBs in current directory
  %(prog)s book.epub          # Convert specific file
  %(prog)s file1.epub file2.epub  # Convert multiple specific files
        '''
    )
    parser.add_argument(
        'files',
        nargs='*',
        help='EPUB file(s) to convert (default: all EPUBs in current directory)'
    )

    args = parser.parse_args()

    # Determine which files to process
    if args.files:
        # Process specified files
        epub_files = []
        for file_arg in args.files:
            file_path = Path(file_arg)
            if not file_path.exists():
                print(f"Error: File not found: {file_arg}")
                continue
            if file_path.suffix.lower() != '.epub':
                print(f"Error: Not an EPUB file: {file_arg}")
                continue
            epub_files.append(file_path)
        
        if not epub_files:
            print("No valid EPUB files specified")
            return
    else:
        # Get all EPUB files in current directory
        epub_files = sorted(Path('.').glob('*.epub'), key=lambda x: natural_sort_key(x.name))

        if not epub_files:
            print("No EPUB files found in current directory")
            return

    print(f"Found {len(epub_files)} EPUB file(s) to convert\n")

    successful = 0
    failed = 0

    for epub_file in epub_files:
        result = convert_epub_to_pdf(epub_file)
        if result is True:
            successful += 1
        elif result is False:
            failed += 1
        print()  # Empty line between conversions

    print(f"{'='*60}")
    print(f"Conversion complete:")
    print(f"  Successful: {successful}")
    print(f"  Failed: {failed}")
    print(f"{'='*60}")

if __name__ == '__main__':
    main()